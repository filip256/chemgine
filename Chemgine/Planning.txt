We need a SMILES interpreter for defining structures, and using third party software
We need to store backbones, functional groups and atoms as singletons for RAM and form molecules from them

=> Thus we need a way to convert SMILES <--> molecule <--> optimized molecule (ideally whithout the molecule middle step)

Optimized molecules = Molecules derived from a backbone using functional groups and atoms.
Backbone = Common molecule like benzene, indole, tryptamine etc.
Functional groups = Incomplete molecules that can be completed by ONE OR MORE atoms, backbones or functional groups
Atom = Most basic unit

-- Storing singletons --
A data manager class is needed that loads the properties of objects from CSV files
Info about an object can be retrieved by a key or id (incremental numeric / string with hashmap)


-- MolecularStructure --
A graph like representation for molecules holding Atoms, FunctionalGroups and Backbones as nodes and Bonds
Hydrogens are implied where needed 


-- Atoms --
Atoms are modeld as a class containg their properties, stored as singletons
Some special atoms need to be defined like: 
 > R (organic radical)
 > A (aromatic radical)
 > Me (metal) 
 (see Functional Groups and Reactions)


-- Functional Groups --
Functional groups are MolecularStructures that contain at least one special atom,
specifying the position where a radical should be inserted


-- Backbones --
Complete MolecularStructures on which substitutions can be made.
New backbones cannot be creaded by the algorithm.

Could a backbone be formed from another backbone?
 - YES:   better memory for storing backbones
          pattern matching could break
 - no:   better memory for atom identifiers, which are more common (only one id needs to be stored)
         backbone reccurrsion could be mentained in data files, bun not in RAM
 - both: establish a hard limit (ie 3) for how deep the reccursion can get


-- Molecules -- 
Complete MolecularStructures. They differ from backbones by being more specific.
Molecules cannot be considered backbones for other molecules.
Some molecules can be defined in files for their properties and new ones can be created and stored by the algorithm.



In an optimized molecular structure there must be a way to specify which atoms are bounded:
  AtomIdentifier can hold a reference to a MolecularStructure and the index of one atoms withing that structure



  Reactions:
   A reaction has a list of reactants, a list of products, a list of conditions and some
   properties like base speed. A mapping between every atom in reactants and those from products
   must be made in a deterministic and trivial way.
   Stoechiometry could be determined.

   Possible CSV:
       id, reactants    , conditions, products     , properties
       10, [smiles, ...], [cat, ...], [smiles, ...], prop ...

  ReactionCondition:
   Polymorphic type with a method that determines to what extent the condition is met.

  PhysicalState: (for later)
   Describes the physical system inside a reactor/environment.


   Stoechiometry:
    1. Name each reactant (Ri) and product (Pi), and their coefficinets (Xi, Yi);
    2. Find the liniar eq of every atom A by:
        SUM[i:0->n] { Xi*(cnt A in Ri) - Yi*(cnt A in Pi) }
    3. Since the system will usually have 1 degree of freedom, the coefficient of 
       the first product is locked in at 1 and thus the number of unknowns is reduced
    4. Solve the system formed by each eq(A) using Gaussian elimination
    5. If needed, multiply coefficients to obtain integers


-- Reactables --
F. groups, backbones, atoms, organics, anorganics can all be reactants and products.
Reactables provide access to the MolecularStructure of each of these types.
They are similar to Components but with a different purpose.
    

-- ConcreteReactions --
Represent the actual reaction that takes place and it is formed by instancing an existing
Reaction with real molecules from a Reactor. In essence they must describe efficiently
exactly what gets consumed and created and must be appliable on a reactor.


-- MergeSubstitute --
A method that receives the molecules X, R, P and a mapping between X-R and R-P and returns a new molecule
similar to P but containing all of the substituents from X.


0 - 1
1 - 5
3 - 2
2 - 0


# How to check if a reaction occurs in a reactor:
   - physical conditions must match
   - catalysts must be present
   - every there must be o molecule that matches every reactant:
      ! molecules, f. groups, bacbones have different matching rules => reactables !
      ! the same molecule can match mutiple reactants !
      ! one reactant must be matched by exactly one molecule !
      ! not all molecules in the reactor need to match (obvious) !

   I.  Easy but bad: Loop through all reactions and check if each reactant matches a molecule, return
       the matching between each reactant and molecule
   II. Faster but more memory: Send a list of molecules to the dataStore. the store does intelligen queries
       and returns a map of {molecules, reactions}

   How to prevent duplicate reactions:
      New reactions should occur when:
       - a new molecule appears => the reaction must contain at least 1 new molecule
       - physical props. change => the new reaction must have a different id from the existing ones

# How to generate a concrete reaction:
    - find a possible reaction
    - decide how many of each of the reacting molecules is needed
    - knowing the molecule-reactant mapping and the reactant-product mapping,
      generate the structures of the products
    - if no molecule is defined with this new structure, define it and approximate properties
    - store the reactant and product lists of molecules
    - approximate reaction speed and themodynamics


Tasks:
  DONE. Create atoms CSV with Id, symbol, valence, weight
  DONE. Create AtomData class for storing properties, initialization from csv line
  DONE. Create DataManager for storing Datas as singletons
---
  DONE. Create BaseComponent, AtomIdentifier, Bond and MolecularStructure classes
  DONE. Create FunctionalGroup derived from BaseComponent
  DONE. Create FunctionalGroups CSV with Id, smiles
  DONE. Create FunctionalGroupData with a MolecularStrcuture and write initilizer from SMILES
---
  DONE. Create Backbone derived from BaseComponent
  DONE. Create Backbones CSV with Id, smiles
  DONE. Create BackboneData with a MolecularStructure and write initilizer from SMILES
---
  DONE. Create OrganicMolecule class
  DONE. Create OrganicMolecules CSV with Id, smiles
  DONE. Create MoleculeData with a MolecularStructure and write initilizer from SMILES
---
  Make sure hydrogen isnt added from smiles into molecules
  ?. Implement BaseReactionCondition
  DONE. Implement ReactionData with CSV loader
  ?. Implement indexing system for reactions
  DONE. Implement maximalMapping
  DONE. Implement reactables and reactable factory
  DONE. Implement reactant - product mapping
  DONE. Implement stoechiometry
  DONE. Implement strict molecule serialization and deserialization
  DONE. Implement pVector
  DONE. Implement query
  DONE. Implement amount
  ?. Accept user balance hints for reactions
  ?. Accept user mapping hints for reactions
  ?. Implement toSMILES
---
  1. Implement reactor 
  DONE. Implement algorithm for checking if a reaction is possible
---
  DONE. Implement graph matching algorithm
  DONE. Hardcode special atom types
  2. Apply algorithm to organic molecules
  DONE. Write molecule to smiles and cmiles algorithm and print to CSV files
  ?. Implement algorithm using BFS
---
  DONE. Molecular structure improvements: isNormalized field (checks for req methods), implied hydrogen clarifications
---
  1. Fix single key DataTables
  2. Fix Reactable id clash (Molecule/Component)
  DONE. Approximator optimizer
  3. Use operator* instead of value() for std::optional
  4. Rename approximator to estimator
---
  DONE. Add heat capacity to molecules as a SplineAppx
  DONE. Add latent heat(fusion and vaporization) to molecules
  DONE. Add table.add<approximator>() method 
  4. Add energy to reactors
  5. Add tests for physiscal properties


Possible optimizations:
 - keep symbols as char* to avoid uneccessary constructor for 'C'
 - avoid contains-then-access for maps
 - const fields in data objects need to be copied (not moved) on reallocation because of const

Categorizations:
 - When a categorization is done with a backbone or f. group, it is applied globally to all other
   backbones, molecules and f. groups
    => comparison matching does not need to check deep links

 - When a categorization is done with the smallest f. group or backbone first. Once a f. group or 
   backbone is used as a pattern it cannot be modified.
    => already formed bond idexes remain valid

 - Radical atoms where binding occurs will remain in the pattern f. group but when accessed
   from target they will be ignored. Same with hydrogen atoms in backbones 
    => patterns remain unchanged singletons

 - Radical atoms remain in the target even if they are mapped by the pattern
    => an f. group remains trivial, i.e. no deep search is required in order to find its radicals

 - Matched patterns are added at the end of the components vector and the replaced atoms are removed
   the end
    => simplifies algorithm

 - Bonds to composite components need vector of ohter for deep ceonnections

 - System needed for normalizing radicals on symetric cycles, p-xylene must be p-xylene no mater the
   position of the methyls. Radicals could always be brought down to the smallest index.


   Reaction activation requirements:
    - all reactants are present in compatible reactor layers
         add trigger: new reactant added
    - activation energy is reached
         cache trigger: activation energy is within range
    - temperature is sufficient
         cache trigger: min react temp is reached
    - catalysts are present
         cache trigger: always
         add trigger: new reactant added


    Physical properties:
      - melting and boiling points:
          They vary with pressure. Data in loaded as the bp and mp and std. pressure.
          An offset approximator is used to get the mp and bp from the std. values and a standard relative bp approximator.

          Defaults to: water.
          Stored as: C


      - densities:
          For solids and liquids:
            They vary by temperature and the variance depends on aggregation state, but not on pressure, thus:
            spline approximators are generated for both liquid and solid densities.
          For gasses:
            The ideal gas law is used.
            Perhaps a more specific approach will be used in the future.

          Defaults to: water.
          Stored as: g/ml


      - heat capacities:
          https://www.tec-science.com/thermodynamics/heat/specific-heat-capacity-of-water/
          For solids:
            Varies with themperature. Spline approximator is used.
          For liquids:
            Almost constant, still a spline approximation can be used. (Consider optimizing 1 and 2 value Splines to constants and functions appx.)
          For gases:
            https://www.tec-science.com/thermodynamics/heat/specific-heat-capacity-of-gases-at-constant-volume-or-pressure/
            Isobaric heat capacity is used. (Most systems will be open, i.e. the volume can expand)
            For monoatomics =5R/2, for diatomics =7R/2, for polyatomics =(degrees_of_freedom + 2)*R/2
            For the rare cases of 'pipe bomb' reactors isochoric could be considered.

          Defaults to: water.
          Stored as: J/mol (molar heat capacity)


      - latent heats:
          For fusion, vaporization and sublimation.
          liquefiation = -fusion, condensation = -fusion, deposition = -sublimation

          It is expected that latent heats for copression are proportional to pressure. 
          It is expected that latent heats for expansion are inversly proportional to pressure.
          A functional approximator can be used.
          (?) If a substance is introduced in a reactor with a temp higher than its bp/mp, less energy is required
          to produce state change, than when heating gradually. <=> Latent heats are inversly proportional with temperature.
          
          Sublimation occurs when it's latent heat < fusion latent heat.
          Deposition occurs when deposition latent heat < condensation.

          Defaults to: water.
          Stored as: J/mol (molar latent heat)


   -----------------------------------------------------------------------------------------------------------------

   LabwareData:
    - all const properties of a type of labware
    - a list of ports



    BaseLabwareData
    |
    |- ContainerData
    |
    |- EquimentData



   Labware:
    - a labware system is a graph of components

   BaseLabComponent:
    - an object that can have some adjacent components and defines the flow between these components
    - have a tick function that defines their effect