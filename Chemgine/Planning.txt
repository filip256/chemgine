We need a SMILES interpreter for defining structures, and using third party software
We need to store backbones, functional groups and atoms as singletons for RAM and form molecules from them

=> Thus we need a way to convert SMILES <--> molecule <--> optimized molecule (ideally whithout the molecule middle step)

Optimized molecules = Molecules derived from a backbone using functional groups and atoms.
Backbone = Common molecule like benzene, indole, tryptamine etc.
Functional groups = Incomplete molecules that can be completed by ONE OR MORE atoms, backbones or functional groups
Atom = Most basic unit

-- Storing singletons --
A data manager class is needed that loads the properties of objects from CSV files
Info about an object can be retrieved by a key or id (incremental numeric / string with hashmap)


-- MolecularStructure --
A graph like representation for molecules holding Atoms, FunctionalGroups and Backbones as nodes and Bonds
Hydrogens are implied where needed 


-- Atoms --
Atoms are modeld as a class containg their properties, stored as singletons
Some special atoms need to be defined like: 
 > R (organic radical)
 > A (aromatic radical)
 > Me (metal) 
 (see Functional Groups and Reactions)


-- Functional Groups --
Functional groups are MolecularStructures that contain at least one special atom,
specifying the position where a radical should be inserted


-- Backbones --
Complete MolecularStructures on which substitutions can be made.
New backbones cannot be creaded by the algorithm.

Could a backbone be formed from another backbone?
 - YES:   better memory for storing backbones
          pattern matching could break
 - no:   better memory for atom identifiers, which are more common (only one id needs to be stored)
         backbone reccurrsion could be mentained in data files, bun not in RAM
 - both: establish a hard limit (ie 3) for how deep the reccursion can get


-- Molecules -- 
Complete MolecularStructures. They differ from backbones by being more specific.
Molecules cannot be considered backbones for other molecules.
Some molecules can be defined in files for their properties and new ones can be created and stored by the algorithm.



In an optimized molecular structure there must be a way to specify which atoms are bounded:
  AtomIdentifier can hold a reference to a MolecularStructure and the index of one atoms withing that structure



  Reactions:
   A reaction has a list of reactants, a list of products, a list of conditions and some
   properties like base speed. A mapping between every atom in reactants and those from products
   must be made in a deterministic and trivial way.
   Stoechiometry could be determined.

   Possible CSV:
       id, reactants    , conditions, products     , properties
       10, [smiles, ...], [cat, ...], [smiles, ...], prop ...

  ReactionCondition:
   Polymorphic type with a method that determines to what extent the condition is met.

  PhysicalState: (for later)
   Describes the physical system inside a reactor/environment.


   Stoechiometry:
    1. Name each reactant (Ri) and product (Pi), and their coefficinets (Xi, Yi);
    2. Find the liniar eq of every atom A by:
        SUM[i:0->n] { Xi*(cnt A in Ri) - Yi*(cnt A in Pi) }
    3. Since the system will usually have 1 degree of freedom, the coefficient of 
       the first product is locked in at 1 and thus the number of unknowns is reduced
    4. Solve the system formed by each eq(A) using Gaussian elimination
    5. If needed, multiply coefficients to obtain integers


-- Reactables --
F. groups, backbones, atoms, organics, anorganics can all be reactants and products.
Reactables provide access to the MolecularStructure of each of these types.
They are similar to Components but with a different purpose.
    

-- ConcreteReactions --
Represent the actual reaction that takes place and it is formed by instancing an existing
Reaction with real molecules from a Reactor. In essence they must describe efficiently
exactly what gets consumed and created and must be appliable on a reactor.

# How to check if a reaction occurs in a reactor:
   - physical conditions must match
   - catalysts must be present
   - every there must be o molecule that matches every reactant:
      ! molecules, f. groups, bacbones have different matching rules => reactables !
      ! the same molecule can match mutiple reactants !
      ! one reactant must be matched by exactly one molecule !
      ! not all molecules in the reactor need to match (obvious) !

   I.  Easy but bad: Loop through all reactions and check if each reactant matches a molecule, return
       the matching between each reactant and molecule
   II. Faster but more memory: Send a list of molecules to the dataStore. the store does intelligen queries
       and returns a map of {molecules, reactions}

   How to prevent duplicate reactions:
      New reactions should occur when:
       - a new molecule appears => the reaction must contain at least 1 new molecule
       - physical props. change => the new reaction must have a different id from the existing ones

# How to generate a concrete reaction:
    - find a possible reaction
    - decide how many of each of the reacting molecules is needed
    - knowing the molecule-reactant mapping and the reactant-product mapping,
      generate the structures of the products
    - if no molecule is defined with this new structure, define it and approximate properties
    - store the reactant and product lists of molecules
    - approximate reaction speed and themodynamics


Tasks:
  DONE. Create atoms CSV with Id, symbol, valence, weight
  DONE. Create AtomData class for storing properties, initialization from csv line
  DONE. Create DataManager for storing Datas as singletons
---
  DONE. Create BaseComponent, AtomIdentifier, Bond and MolecularStructure classes
  DONE. Create FunctionalGroup derived from BaseComponent
  DONE. Create FunctionalGroups CSV with Id, smiles
  DONE. Create FunctionalGroupData with a MolecularStrcuture and write initilizer from SMILES
---
  DONE. Create Backbone derived from BaseComponent
  DONE. Create Backbones CSV with Id, smiles
  DONE. Create BackboneData with a MolecularStructure and write initilizer from SMILES
---
  DONE. Create OrganicMolecule class
  DONE. Create OrganicMolecules CSV with Id, smiles
  DONE. Create OrganicMoleculeData with a MolecularStructure and write initilizer from SMILES
---
  Make sure hydrogen isnt added from smiles into molecules
  ?. Implement BaseReactionCondition
  DONE. Implement ReactionData with CSV loader
  ?. Implement indexing system for reactions
  DONE. Implement maximalMapping
  DONE. Implement reactables and reactable factory
  DONE. Implement reactant - product mapping
  DONE. Implement stoechiometry
  DONE. Implement strict molecule serialization and deserialization
  DONE. Implement pVector
  DONE. Implement query
  DONE. Implement amount
  ?. Accept user balance hints for reactions
  ?. Accept user mapping hints for reactions
  ?. Implement toSMILES
---
  1. Implement reactor 
  6. Implement algorithm for checking if a reaction is possible
---
  DONE. Implement graph matching algorithm
  DONE. Hardcode special atom types
  2. Apply algorithm to organic molecules
  3. Write molecule to smiles and cmiles algorithm and print to CSV files
  ?. Implement algorithm using BFS


Possible optimizations:
 - keep symbols as char* to avoid uneccessary constructor for 'C'
 - avoid contains-then-access for maps
 - const fields in data objects need to be copied (not moved) on reallocation because of const

Categorizations:
 - When a categorization is done with a backbone or f. group, it is applied globally to all other
   backbones, molecules and f. groups
    => comparison matching does not need to check deep links

 - When a categorization is done with the smallest f. group or backbone first. Once a f. group or 
   backbone is used as a pattern it cannot be modified.
    => already formed bond idexes remain valid

 - Radical atoms where binding occurs will remain in the pattern f. group but when accessed
   from target they will be ignored. Same with hydrogen atoms in backbones 
    => patterns remain unchanged singletons

 - Radical atoms remain in the target even if they are mapped by the pattern
    => an f. group remains trivial, i.e. no deep search is required in order to find its radicals

 - Matched patterns are added at the end of the components vector and the replaced atoms are removed
   the end
    => simplifies algorithm

 - Bonds to composite components need vector of ohter for deep ceonnections

 - System needed for normalizing radicals on symetric cycles, p-xylene must be p-xylene no mater the
   position of the methyls. Radicals could always be brought down to the smallest index.


