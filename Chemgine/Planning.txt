We need a SMILES interpreter for defining structures, and using third party software
We need to store backbones, functional groups and atoms as singletons for RAM and form molecules from them

=> Thus we need a way to convert SMILES <--> molecule <--> optimized molecule (ideally whithout the molecule middle step)

Optimized molecules = Molecules derived from a backbone using functional groups and atoms.
Backbone = Common molecule like benzene, indole, tryptamine etc.
Functional groups = Incomplete molecules that can be completed by ONE OR MORE atoms, backbones or functional groups
Atom = Most basic unit

-- Storing singletons --
A data manager class is needed that loads the properties of objects from CSV files
Info about an object can be retrieved by a key or id (incremental numeric / string with hashmap)


-- MolecularStructure --
A graph like representation for molecules holding Atoms, FunctionalGroups and Backbones as nodes and Bonds
Hydrogens are implied where needed 


-- Atoms --
Atoms are modeld as a class containg their properties, stored as singletons
Some special atoms need to be defined like: 
 > R (organic radical)
 > A (aromatic radical)
 > Me (metal) 
 (see Functional Groups and Reactions)


-- Functional Groups --
Functional groups are MolecularStructures that contain at least one special atom,
specifying the position where a radical should be inserted


-- Backbones --
Complete MolecularStructures on which substitutions can be made.
New backbones cannot be creaded by the algorithm.

Could a backbone be formed from another backbone?
 - YES:   better memory for storing backbones
          pattern matching could break
 - no:   better memory for atom identifiers, which are more common (only one id needs to be stored)
         backbone reccurrsion could be mentained in data files, bun not in RAM
 - both: establish a hard limit (ie 3) for how deep the reccursion can get


-- Molecules -- 
Complete MolecularStructures. They differ from backbones by being more specific.
Molecules cannot be considered backbones for other molecules.
Some molecules can be defined in files for their properties and new ones can be created and stored by the algorithm.



In an optimized molecular structure there must be a way to specify which atoms are bounded:
  AtomIdentifier can hold a reference to a MolecularStructure and the index of one atoms withing that structure



  Reactions:
   A reaction has a list of reactants, a list of products, a list of conditions and some
   properties like base speed. A mapping between every atom in reactants and those from products
   must be made in a deterministic and trivial way.
   Stoechiometry could be determined.

   Possible CSV:
       id, reactants    , conditions, products     , properties
       10, [smiles, ...], [cat, ...], [smiles, ...], prop ...

  ReactionCondition:
   Polymorphic type with a method that determines to what extent the condition is met.

  PhysicalState: (for later)
   Describes the physical system inside a reactor/environment.
    


Tasks:
  DONE. Create atoms CSV with Id, symbol, valence, weight
  DONE. Create AtomData class for storing properties, initialization from csv line
  DONE. Create DataManager for storing Datas as singletons
---
  DONE. Create BaseComponent, AtomIdentifier, Bond and MolecularStructure classes
  DONE. Create FunctionalGroup derived from BaseComponent
  DONE. Create FunctionalGroups CSV with Id, smiles
  DONE. Create FunctionalGroupData with a MolecularStrcuture and write initilizer from SMILES
---
  DONE. Create Backbone derived from BaseComponent
  DONE. Create Backbones CSV with Id, smiles
  DONE. Create BackboneData with a MolecularStructure and write initilizer from SMILES
---
  DONE. Create OrganicMolecule class
  DONE. Create OrganicMolecules CSV with Id, smiles
  DONE. Create OrganicMoleculeData with a MolecularStructure and write initilizer from SMILES
---
  1. Implement BaseReactionCondition
  2. Implement ReactionData with CSV loader
  3. Implement indexing system for reactions
  4. Implement algorithm for checking if a reaction is possible
---
  1. Implement reactor 
---
  DONE. Implement graph matching algorithm
  DONE. Hardcode special atom types
  2. Apply algorithm to organic molecules
  3. Write molecule to smiles and cmiles algorithm and print to CSV files
  ?. Implement algorithm using BFS


Possible optimizations:
 - keep symbols as char* to avoid uneccessary constructor for 'C'
 - avoid contains-then-access for maps
 - const fields in data objects need to be copied (not moved) on reallocation because of const

Categorizations:
 - When a categorization is done with a backbone or f. group, it is applied globally to all other
   backbones, molecules and f. groups
    => comparison matching does not need to check deep links

 - When a categorization is done with the smallest f. group or backbone first. Once a f. group or 
   backbone is used as a pattern it cannot be modified.
    => already formed bond idexes remain valid

 - Radical atoms where binding occurs will remain in the pattern f. group but when accessed
   from target they will be ignored. Same with hydrogen atoms in backbones 
    => patterns remain unchanged singletons

 - Radical atoms remain in the target even if they are mapped by the pattern
    => an f. group remains trivial, i.e. no deep search is required in order to find its radicals

 - Matched patterns are added at the end of the components vector and the replaced atoms are removed
   the end
    => simplifies algorithm

 - Bonds to composite components need vector of ohter for deep ceonnections

 - System needed for normalizing radicals on symetric cycles, p-xylene must be p-xylene no mater the
   position of the methyls. Radicals could always be brought down to the smallest index.


